import * as axios from 'axios';
import * as _shared_core from './clients/core';
import { APIParams as APIParams$1, ClientParams as ClientParams$1, FeeConfiguration, WithIdempotencyKey, Pagination } from './clients/core';
export { APIParams as CoreAPIParams, ClientParams as CoreClientParams, FeeConfiguration, Pagination, Storage, TrimDataResponse, WithIdempotencyKey } from './clients/core';
import * as _shared_clients_smart_contract_platform from './clients/smart-contract-platform';
import { SmartContractPlatformClient, Blockchain, FeeLevel, ContractInputType, ContractStatus, AbiParametersInner } from './clients/smart-contract-platform';
export { AbiParametersInner, Blockchain, Contract, ContractDeployment, ContractDeploymentData, ContractDeploymentEstimateFeeRequest, ContractDeploymentEstimateRequest, ContractDeploymentRequest, ContractInputType, ContractResponse, ContractResponseData, ContractStatus, Contracts, ContractsData, CreateEventMonitorRequest, Event, EventLog, EventLogs, EventLogsData, EventMonitor, EventMonitorResponse, EventMonitorResponseData, EventMonitors, EventMonitorsData, FeeEstimation, FeeEstimationData, FeeLevel, Function, ImportContractRequest, ParamType, PatchContractRequest, ReadContractState, ReadContractStateData, ReadContractStateRequest, SmartContractPlatformClient, SolFile, TemplateContractDeployment, TemplateContractDeploymentData, TemplateContractDeploymentRequest, TemplatesApi, TransactionFee, UpdateEventMonitorRequest, VerificationStatus } from './clients/smart-contract-platform';
export { BadRequestResponse, CreateMonitoredTokensRequest, CreateSubscriptionRequest, DeleteMonitoredTokensRequest, EntityConfig, EntityConfigData, FaucetRequest, ModelError, MonitoredTokens, MonitoredTokensData, NotAuthorizedResponse, NotFoundResponse, NotificationSignaturePublicKey, NotificationSignaturePublicKeyData, NotificationType, Ping, PublicKey, PublicKeyData, Subscription, SubscriptionResponse, Subscriptions, TestnetBlockchain, Token, TokenMonitorScope, TokenStandard, UpdateMonitoredTokensRequest, UpdateMonitoredTokensScopeRequest, UpdateSubscriptionRequest } from './clients/configurations';

/**
 * Type of the data that is stored.
 */
type StoredData = {
    /**
     * The publicKey that is associated to the entity.
     */
    publicKey: string;
};
interface Config {
    /**
     * Your configured entity secret.
     */
    entitySecret: string;
}
type APIParams = APIParams$1<SmartContractPlatformClient, StoredData> & Config;
type ClientParams = ClientParams$1<StoredData> & Config;
/**
 * Represents the input parameters for deploying a contract.
 */
type DeployContractInput = {
    /**
     * The contract's name.
     */
    name: string;
    /**
     * The description for the contract.
     */
    description?: string;
    /**
     * Unique identifier of the wallet that will deploy the contract.
     */
    walletId: string;
    /**
     * The contract's ABI in a JSON stringified format.
     */
    abiJson: string;
    /**
     * Bytecode of the contract being deployed.
     */
    bytecode: string;
    /**
     * The blockchain on which the contract will be deployed.
     */
    blockchain: Blockchain;
    /**
     * A list of arguments to pass to the contract's constructor function. Must be an empty array if there are no constructor parameters.
     */
    constructorParameters?: any[];
    /**
     * Configuration that determines the fees that will be paid.
     */
    fee: FeeConfiguration<FeeLevel>;
    /**
     * The reference ID for the operation, to ensure idempotency.
     */
    refId?: string;
} & WithIdempotencyKey;
/**
 * Represents the input for deploying a contract.
 */
type EstimateDeploymentFeeInput = {
    /**
     * Blockchain is the blockchain to deploy onto.
     */
    blockchain?: Blockchain;
    /**
     * Bytecode of the contract being deployed.
     */
    bytecode: string;
    /**
     * The contract's ABI in a JSON stringified format.
     */
    abiJson?: string;
    /**
     * Signature of the constructor if the contract has one. Constructor() by default.
     */
    constructorSignature?: string;
    /**
     * A list of arguments to pass to the contract\'s constructor function. Must be an empty array if there are no constructor parameters.
     */
    constructorParameters?: Array<any>;
    /**
     * The source address of the transaction.
     */
    sourceAddress?: string;
    /**
     * Unique identifier of the wallet that will deploy the contract.
     */
    walletId?: string;
};
/**
 * Represents the input for fetching a contract.
 */
type GetContractInput = {
    /**
     * The contract's ID.
     */
    id: string;
};
/**
 * Represents the input for deploying a contract.
 */
type ImportContractInput = {
    /**
     * The contract's name.
     */
    name: string;
    /**
     * The description for a contract.
     */
    description?: string;
    /**
     * Address is the address of the contract to be imported.
     */
    address: string;
    /**
     * Blockchain is the blockchain to deploy onto.
     */
    blockchain: Blockchain;
} & WithIdempotencyKey;
/**
 * Represents the input for fetching all contracts.
 */
type ListContractsInput = {
    /**
     * Filter by blockchain.
     */
    blockchain?: Blockchain;
    /**
     * Filter contracts by input type.
     */
    contractInputType?: ContractInputType;
    /**
     * Filter contracts by deployer address.
     */
    deployerAddress?: string;
    /**
     * Filter contracts by name.
     */
    name?: string;
    /**
     * Filter contracts by status.
     */
    status?: ContractStatus;
} & Pagination;
/**
 * Represents the input parameters for deploying a contract.
 */
type QueryContractInput = {
    /**
     * The contract ABI function signature or `callData` field is required for interacting with the smart contract. The ABI function signature cannot be used simultaneously with `callData`. e.g. Burn(uint256).
     */
    abiFunctionSignature?: string;
    /**
     * The contract ABI function signature parameters for executing the contract interaction. Supported parameter types include string, integer, boolean, and array. These parameters should be used exclusively with the abiFunctionSignature and cannot be used with `callData`.
     */
    abiParameters?: Array<AbiParametersInner>;
    /**
     * The contract's ABI in a JSON stringified format.
     */
    abiJson?: string;
    /**
     * Address of the contract to be queried.
     */
    address: string;
    /**
     * Blockchain of the contract to be queried.
     */
    blockchain: Blockchain;
    /**
     * CallData is input data that encodes method and parameters.
     */
    callData?: string;
    /**
     * FromAddress is the address that will populate msg.sender in the contract call.
     */
    fromAddress?: string;
};
/**
 * Represents the input for reading a contract.
 */
type ReadContractInput = {
    /**
     * The contract's ID.
     */
    id: string;
    /**
     * The ABI function signature field is required for interacting with the smart contract.
     * Example: Burn(uint256).
     */
    abiFunctionSignature: string;
    /**
     * The ABI function signature parameters for executing the contract interaction. Supported parameter types include string, integer, boolean, and array.
     */
    abiParameters?: Array<any>;
};
/**
 * Represents the input for updating contract off-chain properties.
 */
type UpdateContractInput = {
    /**
     * The contract's ID.
     */
    id: string;
    /**
     * The contract's name.
     */
    name?: string;
    /**
     * The description for a contract.
     */
    description?: string;
    /**
     * The archive state of the contract. If true, the contract will not be visible in your dashboard.
     */
    archived?: boolean;
};
/**
 * Represents the input parameters for deploying a contract using a template.
 */
type DeployContractTemplateInput = {
    /**
     * The template's ID.
     */
    id: string;
    /**
     * The blockchain on which the contract will be deployed.
     */
    blockchain: Blockchain;
    /**
     * The wallet's ID that will be used as the source for the contract deployment.
     */
    walletId: string;
    /**
     * The contract's name.
     */
    name: string;
    /**
     * The description for the contract.
     */
    description?: string;
    /**
     * JSON object that contains the template deployment parameters used to initialize the contract(s) on-chain.
     */
    templateParameters?: Record<string, string>;
    /**
     * Configuration that determines the fees that will be paid.
     */
    fee: FeeConfiguration<FeeLevel>;
    /**
     * The reference ID for the operation, to ensure idempotency.
     */
    refId?: string;
} & WithIdempotencyKey;
/**
 * Represents the input for deploying a contract using a template.
 */
type EstimateContractTemplateDeploymentFeeInput = {
    /**
     * The template's ID.
     */
    id: string;
    /**
     * The blockchain on which the contract will be deployed.
     */
    blockchain: Blockchain;
    /**
     * The source address of the transaction.
     */
    sourceAddress?: string;
    /**
     * JSON object that contains the template deployment parameters used to initialize the contract(s) on-chain.
     */
    templateParameters: Record<string, string>;
    /**
     * Unique identifier of the wallet that will deploy the contract.
     */
    walletId?: string;
};
/**
 * Represents the input for fetching event monitors.
 */
type ListEventMonitorsInput = {
    contractAddress?: string;
    blockchain?: Blockchain;
    eventSignature?: string;
} & Pagination;
/**
 * Represents the input for creating an event monitor.
 */
type CreateEventMonitorInput = {
    /**
     * Create a new event monitor based on the provided blockchain.
     */
    blockchain: Blockchain;
    /**
     * The on-chain address of this contract.
     */
    contractAddress: string;
    /**
     * The specific event to which you want to subscribe. Please ensure no spaces are included.
     */
    eventSignature: string;
} & WithIdempotencyKey;
/**
 * Represents the input for updating an event monitor.
 */
type UpdateEventMonitorInput = {
    /**
     * Event Monitor ID.
     */
    id: string;
    /**
     * Indicates whether the event monitor should be active (true) or inactive (false).
     */
    isEnabled: boolean;
};
/**
 * Represents the input for deleting a event monitor.
 */
type DeleteEventMonitorsInput = {
    /**
     * Event Monitor ID.
     */
    id: string;
};
/**
 * Represents the input for listing all event logs.
 */
type ListEventLogsInput = {
    contractAddress?: string;
    blockchain?: Blockchain;
} & Pagination;

declare const defaultBaseUrl = "https://api.circle.com";

/**
 * A class-based client for Circle's Smart Contract Platform.
 * All operations are available as class methods.
 * @example
 * ```
 * import { CircleSmartContractPlatformClient } from '@circle-fin/smart-contract-platform'
 *
 * const client = new CircleSmartContractPlatformClient({
 *   apiKey: 'YOUR_KEY',
 *   entitySecret: 'YOUR_SECRET',
 * })
 *
 * const response = await client.listContracts()
 * console.log(response.data?.contracts)
 * ```
 */
declare class CircleSmartContractPlatformClient {
    private readonly params;
    /**
     * Creates an instance of CircleSmartContractPlatformClient.
     * @param config - API key, entity secret, optional baseUrl.
     */
    constructor(config: ClientParams);
    /**
     * Deploy a smart contract on a specified blockchain using the contract's ABI and bytecode. The deployment will originate from one of your Circle Programmable Wallets.
     * @example
     * ```
     * const response = await client.deployContract({
     *   name: 'First Contract',
     *   description: 'My first hello world contract',
     *   blockchain: 'ETH-SEPOLIA',
     *   walletId: '004735f6-d9fc-44f8-933c-672cdf3d240d',
     *   abiJson: '[\n\t{\n\t\t\'inputs\': [],\n\t\t\'stateMutability\': \'nonpayable\',\n\t\t\'type\': \'constructor\'\n\t},\n\t...',
     *   bytecode: '0x60806040523480156200001157600080fd5b50604051806040...',
     *   constructorParameters: ['TICK',10000],
     *   fee: {
     *     type: 'level',
     *     config: {
     *       feeLevel: 'HIGH',
     *     },
     *   },
     * })
     * console.log(response.data)
     * ```
     * @category Contracts
     */
    deployContract(input: DeployContractInput): Promise<_shared_core.TrimDataResponse<_shared_clients_smart_contract_platform.ContractDeployment>>;
    /**
     * Estimates the network fee for deploying a smart contract on a specified blockchain, given the contract bytecode.
     * @example
     * ```
     * const response = await client.estimateContractDeploymentFee({
     *   sourceAddress: '0x1bf9ad0cc2ad298c69a2995aa806ee832788218c',
     *   blockchain: 'MATIC-AMOY',
     *   bytecode: '0x60806040523480156200001157600080fd5b50604051806040...',
     *   constructorSignature: 'constructor(string ticker, uint256 totalSupply)',
     *   constructorParameters: [ 'TICK', 10000],
     * })
     * console.log(response.data)
     * ```
     * @category Contracts
     */
    estimateContractDeploymentFee(input: EstimateDeploymentFeeInput): Promise<_shared_core.TrimDataResponse<_shared_clients_smart_contract_platform.FeeEstimation>>;
    /**
     * Add an existing smart contract to your library of contracts. It also can be done in the Web3 Services Console.
     * @example
     * ```
     * const response = await client.importContract({
     *   name: 'testContract',
     *   description: 'testDescription',
     *   address: '0xa51c9c604b79a0fadbfed35dd576ca1bce71da0a',
     *   blockchain: 'ETH-SEPOLIA',
     * })
     * console.log(response.data)
     * ```
     * @category Contracts
     */
    importContract(input: ImportContractInput): Promise<_shared_core.TrimDataResponse<_shared_clients_smart_contract_platform.ContractResponse>>;
    /**
     * Retrieves a single contract that you've imported or deployed. You need to provide the contract's ID instead of the on-chain address.
     * @example
     * ```
     * const response = await client.getContract({
     *   id: '39c7146d-d240-45c3-9402-8d817a633b17',
     * })
     * console.log(response.data)
     * ```
     * @category Contracts
     */
    getContract(input: GetContractInput): Promise<_shared_core.TrimDataResponse<_shared_clients_smart_contract_platform.ContractResponse>>;
    /**
     * Fetch a list of contracts that you've imported and/or deployed.
     * @example
     * ```
     * const response = await client.listContracts({
     *   blockchain: 'MATIC-AMOY',
     *   status: 'COMPLETE',
     *   contractInputType: 'IMPORT',
     * })
     * console.log(response.data)
     * ```
     * @category Contracts
     */
    listContracts(input?: ListContractsInput): Promise<_shared_core.TrimDataResponse<_shared_clients_smart_contract_platform.Contracts>>;
    /**
     * Update the off-chain properties, such as description, of a contract that you've imported or deployed.
     *
     * This method uses the contract's ID instead of the on-chain address.
     * @example
     * ```
     * const response = await client.updateContract({
     *   id: 'c4d1da72-111e-4d52-bdbf-2e74a2d803d5',
     *   archived: true,
     * })
     * console.log(response.data)
     * ```
     * @category Contracts
     */
    updateContract(input: UpdateContractInput): Promise<_shared_core.TrimDataResponse<_shared_clients_smart_contract_platform.ContractResponse>>;
    /**
     * Query the state of a contract by providing the address and blockchain.
     * @example
     * ```
     * const response = await client.queryContract({
     *   blockchain: "MATIC-AMOY",
     *   address: "0xfea0e6a371a0eb204dbfae2ee38eeedeebe15ed7",
     *   callData: "0x0000000000000000000000000000000000000000000000000000000000000000",
     * })
     * console.log(response.data)
     * ```
     * @category Contracts
     */
    queryContract(input: QueryContractInput): Promise<_shared_core.TrimDataResponse<_shared_clients_smart_contract_platform.ReadContractState>>;
    /**
     * Deploy a smart contract using a template.
     * @example
     * ```
     * const response = await client.deployContractTemplate({
     *   id: 'cf930871-bc29-43f0-9abb-0af6e66bd8db',
     *   blockchain: 'MATIC-AMOY',
     *   templateParameters: {},
     *   walletId: '3962046c-4bd3-43ca-bb84-0c8f7dbfa798',
     *   fee: {
     *     type: 'level',
     *     config: {
     *       feeLevel: 'HIGH',
     *     },
     *   },
     *   name: 'Contract name',
     * })
     * console.log(response.data)
     * ```
     * @category Contract Templates
     */
    deployContractTemplate(input: DeployContractTemplateInput): Promise<_shared_core.TrimDataResponse<_shared_clients_smart_contract_platform.TemplateContractDeployment>>;
    /**
     * Estimate the fee required to deploy contract by template.
     * @example
     * ```
     * const response = await client.estimateContractTemplateDeploymentFee({
     *   id: "cf930871-bc29-43f0-9abb-0af6e66bd8db",
     *   blockchain: "MATIC-AMOY",
     *   sourceAddress: "0xfea0e6a371a0eb204dbfae2ee38eeedeebe15ed7",
     *   templateParameters: {},
     * })
     * console.log(response.data)
     * ```
     * @category Contract Templates
     */
    estimateContractTemplateDeploymentFee(input: EstimateContractTemplateDeploymentFeeInput): Promise<_shared_core.TrimDataResponse<_shared_clients_smart_contract_platform.FeeEstimation>>;
    /**
     * Create a new event monitor based on the provided blockchain, contract address, and event signature.
     * @example
     * ```
     * const response = await client.createEventMonitor({
     *   blockchain: 'ETH',
     *   contractAddress: '0x71C7656EC7ab88b098defB751B7401B5f6d8976F',
     *   eventSignature: 'Transfer(address,address,uint256)',
     * })
     * console.log(response.data)
     * ```
     * @category Event Monitors
     */
    createEventMonitor(input: CreateEventMonitorInput): Promise<_shared_core.TrimDataResponse<_shared_clients_smart_contract_platform.EventMonitorResponse>>;
    /**
     * Fetch a list of event monitors, optionally filtered by blockchain, contract address, and event signature.
     * @example
     * ```
     * const response = await client.listEventMonitors()
     * console.log(response.data)
     * ```
     * @category Event Monitors
     */
    listEventMonitors(input: ListEventMonitorsInput): Promise<_shared_core.TrimDataResponse<_shared_clients_smart_contract_platform.EventMonitors>>;
    /**
     * Update an existing event monitor given its ID.
     * @example
     * ```
     * const response = await client.updateEventMonitor({
     *   id: 'c4d1da72-111e-4d52-bdbf-2e74a2d803d5',
     *   isEnabled: true,
     * })
     * console.log(response.data)
     * ```
     * @category Event Monitors
     */
    updateEventMonitor(input: UpdateEventMonitorInput): Promise<_shared_core.TrimDataResponse<_shared_clients_smart_contract_platform.EventMonitorResponse>>;
    /**
     * Delete an existing event monitor given its ID.
     * @example
     * ```
     * const response = await client.deleteEventMonitor({
     *   id: 'c4d1da72-111e-4d52-bdbf-2e74a2d803d5',
     * })
     * console.log(response.data)
     * ```
     * @category Event Monitors
     */
    deleteEventMonitor(input: DeleteEventMonitorsInput): Promise<axios.AxiosResponse<void, any>>;
    /**
     * Fetch all event logs, optionally filtered by blockchain and contract address.
     * @example
     * ```
     * const response = await client.listEventLogs()
     * console.log(response.data)
     * ```
     * @category Event Monitors
     */
    listEventLogs(input: ListEventLogsInput): Promise<_shared_core.TrimDataResponse<_shared_clients_smart_contract_platform.EventLogs>>;
}
/**
 * Initiates a client for Circle's Smart Contract Platform.
 * @example
 * ```
 * import { initiateSmartContractPlatformClient } from '@circle-fin/smart-contract-platform'
 *
 * const client = initiateSmartContractPlatformClient({
 *   apiKey: 'YOUR_KEY',
 *   entitySecret: 'YOUR_SECRET',
 * })
 *
 * const response = await client.listContracts({
 *   blockchain: 'MATIC-AMOY',
 *   status: 'COMPLETE',
 *   contractInputType: 'IMPORT',
 * })
 * console.log(response.data?.contracts)
 * ```
 * @param config - The client parameters.
 * @returns - The client object with various methods.
 * @category Initialization
 */
declare function initiateSmartContractPlatformClient(config: ClientParams): CircleSmartContractPlatformClient;

export { type APIParams, CircleSmartContractPlatformClient, type ClientParams, type Config, type CreateEventMonitorInput, type DeleteEventMonitorsInput, type DeployContractInput, type DeployContractTemplateInput, type EstimateContractTemplateDeploymentFeeInput, type EstimateDeploymentFeeInput, type GetContractInput, type ImportContractInput, type ListContractsInput, type ListEventLogsInput, type ListEventMonitorsInput, type QueryContractInput, type ReadContractInput, type StoredData, type UpdateContractInput, type UpdateEventMonitorInput, defaultBaseUrl, initiateSmartContractPlatformClient };
