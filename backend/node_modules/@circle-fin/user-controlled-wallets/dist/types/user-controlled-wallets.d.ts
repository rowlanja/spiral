import * as _shared_clients_configurations from './clients/configurations';
export { BadRequestResponse, CreateMonitoredTokensRequest, CreateSubscriptionRequest, DeleteMonitoredTokensRequest, EntityConfig, EntityConfigData, FaucetRequest, ModelError, MonitoredTokens, MonitoredTokensData, NotAuthorizedResponse, NotFoundResponse, NotificationSignaturePublicKey, NotificationSignaturePublicKeyData, Ping, PublicKey, PublicKeyData, Subscription, SubscriptionResponse, Subscriptions, TestnetBlockchain, Token, TokenMonitorScope, UpdateMonitoredTokensRequest, UpdateMonitoredTokensScopeRequest, UpdateSubscriptionRequest } from './clients/configurations';
import * as axios from 'axios';
import * as _shared_core from './clients/core';
import { APIParams as APIParams$1, ClientParams as ClientParams$1, WithIdempotencyKey, FeeConfiguration, Pagination, RequestTestnetTokensInput, CreateMonitoredTokensInput, UpdateMonitoredTokensInput, ListMonitoredTokensInput, DeleteMonitoredTokensInput, UpdateMonitoredTokensScopeInput, CreateSubscriptionInput, UpdateSubscriptionInput } from './clients/core';
export { APIParams as CoreAPIParams, ClientParams as CoreClientParams, CreateMonitoredTokensInput, CreateSubscriptionInput, DeleteMonitoredTokensInput, FeeConfiguration, ListMonitoredTokensInput, Pagination, RequestTestnetTokensInput, Storage, TrimDataResponse, UpdateMonitoredTokensInput, UpdateMonitoredTokensScopeInput, UpdateSubscriptionInput, WithIdempotencyKey } from './clients/core';
import * as _shared_clients_user_controlled_wallets from './clients/user-controlled-wallets';
import { TokenBlockchain, UserControlledWalletsClient, Blockchain, WalletMetadata, AccountType, FeeLevel, ContractExecutionBlockchain, TransactionType, ListTransactionsOperationEnum, TransactionState, ListUsersPinStatusEnum, ListUsersSecurityQuestionStatusEnum, ListUserChallengesStatusEnum, TokenStandard, ScaCore, UserTokenResponseData } from './clients/user-controlled-wallets';
export { AbiParametersInner, AccelerateTransactionForEndUserRequest, AccelerateTransactionForEndUserResponse, AccountType, Balance, Balances, BalancesData, BaseScreeningDecision, Blockchain, CancelTransactionForEndUserRequest, CancelTransactionForEndUserResponse, Challenge, ChallengeResponse, ChallengeResponseData, ChallengeStatusEnum, ChallengeTypeEnum, Challenges, ChallengesData, ContractExecutionBlockchain, CreateContractExecutionTransactionForEndUserRequest, CreateContractExecutionTransactionForEndUserResponse, CreateEndUserWallet, CreateEndUserWalletRequest, CreateTransferTransactionForEndUserRequest, CreateTransferTransactionForEndUserResponse, CreateUserRequest, CreateWalletUpgradeTransactionForEndUserRequest, CreateWalletUpgradeTransactionForEndUserResponse, CustodyType, DeviceTokenEmail, DeviceTokenEmailData, DeviceTokenEmailRequest, DeviceTokenSocial, DeviceTokenSocialData, DeviceTokenSocialRequest, EOAWallet, EndUser, EndUserSecurityQuestionStatusEnum, EndUserStatus, EstimateContractExecutionTransactionFeeRequest, EstimateTransactionFee, EstimateTransactionFeeData, EstimateTransferTransactionFeeRequest, FeeLevel, GetUserByIDResponse, GetUserByIDResponseData, ListTransactionsOperationEnum, ListUserChallengesStatusEnum, ListUsersPinStatusEnum, ListUsersSecurityQuestionStatusEnum, NewScaCore, Nft, Nfts, NftsData, Operation, Pin, PinData, PinSecurityDetails, PinStatus, RefreshUserToken, RefreshUserTokenData, RefreshUserTokenRequest, ResendOTPRequest, ResentOTP, ResentOTPData, RiskAction, RiskCategory, RiskScore, RiskSignal, RiskSignalSourceEnum, RiskType, SCAWallet, ScaCore, SetPinAndInitWalletRequest, SetPinRequest, SignMessageRequest, SignTransactionResponse, SignTypedDataRequest, SignUserTransactionRequest, Signature, TokenBlockchain, TokenResponse, TokenResponseData, TokenStandard, Transaction, TransactionFee, TransactionResponse, TransactionResponseData, TransactionScreeningDecision, TransactionState, TransactionType, Transactions, TransactionsData, UpdateWalletRequest, UserResponse, UserTokenRequest, UserTokenResponse, UserTokenResponseData, Users, UsersData, ValidateAddress, ValidateAddressData, ValidateAddressRequest, Wallet, WalletMetadata, WalletResponse, WalletResponseData, WalletResponseDataWallet, WalletState, Wallets, WalletsData } from './clients/user-controlled-wallets';

/**
 * Represents input parameters for identifying a user using a JWT token.
 */
interface UserTokenInput {
    /**
     * The JSON Web Token (JWT) representing the user.
     */
    userToken: string;
    userId?: never;
}
/**
 * Represents input parameters for identifying a user using their system-generated unique identifier.
 */
interface UserIdInput {
    userToken?: never;
    /**
     * Unique system-generated identifier for the user.
     */
    userId: string;
}
interface TokenIdInput {
    /**
     * System generated identifier of the token. Excluded with `tokenAddress` and `tokenBlockchain`.
     */
    tokenId: string;
    tokenAddress?: never;
    blockchain?: never;
}
interface TokenAddressAndBlockchainInput {
    tokenId?: never;
    /**
     * Blockchain address of the transferred token. Empty for native tokens. Excluded with `tokenId`.
     */
    tokenAddress: string;
    /**
     * Blockchain of the transferred token. Required if tokenId is not provided. Excluded with `tokenId`.
     */
    blockchain?: TokenBlockchain;
}
/**
 * Represents input parameters that can be either UserTokenInput or UserIdInput.
 */
type UserIdOrTokenInput = UserIdInput | UserTokenInput;
/**
 * Represents input parameters that can be either UserTokenInput or UserIdInput.
 */
type TokenInfo = TokenIdInput | TokenAddressAndBlockchainInput;
/**
 * Represents a user token that is cached along with its expiration time.
 */
type CachedUserToken = UserTokenResponseData & {
    /**
     * The expiration time in seconds for the cached user token.
     */
    expirationTime: number;
};
type APIParams = APIParams$1<UserControlledWalletsClient, Record<string, CachedUserToken>>;
type ClientParams = ClientParams$1<Record<string, CachedUserToken>>;
/**
 * Represents the input for creating a challenge for PIN setup and create wallet(s).
 */
type CreateUserPinWithWalletsInput = {
    /**
     * Blockchain(s) the requested wallets will be created on.
     */
    blockchains: Blockchain[];
    /**
     * List of metadata fields to associate with the corresponding wallet.
     */
    metadata?: WalletMetadata[];
    /**
     * An account can be categorized as a Smart Contract Account (SCA) or an Externally Owned Account (EOA). For detailed information about these account types and their distinctions, please refer to the account types guide.
     *
     * By default, if an account type is not specified when creating a wallet, it will be classified as an Externally Owned Account (EOA).
     */
    accountType?: AccountType;
} & UserIdOrTokenInput & WithIdempotencyKey;
/**
 * Represents the input to sign the EIP-191 message from a specified user-controlled wallet.
 */
type SignMessageInput = {
    /**
     * Unique system generated identifier of the wallet.
     */
    walletId: string;
    /**
     * Indicator of whether the input message is encoded by hex. If TRUE, then the message should be a hex string. By default, it is False.
     */
    encodedByHex?: boolean;
    /**
     * The user friendly message that needs to be signed.
     * If it is a hex string, encodedByHex needs to be TRUE. The hex string should start with “0x” and have even length.
     */
    message: string;
    /**
     * The human readable explanation for this sign action. Useful for presenting with extra information.
     */
    memo?: string;
} & UserIdOrTokenInput;
/**
 * Represents the input to sign the EIP-191 message from a specified user-controlled wallet.
 */
type SignTransactionInput = {
    /**
     * System-generated unique identifier of the resource.
     */
    walletId: string;
    /**
     * Raw transaction string that needs to be signed. Excluded with `transaction`. Required without `transaction`.
     *
     * Required to be base64 encoded for NEAR, Solana chains. Required to be hex encoded for EVM chains.
     */
    rawTransaction?: string;
    /**
     * Transaction object in JSON that needs to be signed. Excluded with `rawTransaction`. Required without `rawTransaction`.
     *
     * NOTE: This field is only supported by `EVM` chains.
     */
    transaction?: string;
    /**
     * The human readable explanation for this sign action. Useful for presenting with extra information.
     */
    memo?: string;
} & UserIdOrTokenInput;
/**
 * Represents the input to sign the EIP-712 typed structured data from a specified user-controlled wallet.
 */
type SignTypedDataInput = {
    /**
     * Unique system generated identifier of the wallet.
     */
    walletId: string;
    /**
     * A string represents the typed structured data in EIP-712.
     */
    data: string;
    /**
     * The human readable explanation for this sign action. Useful for presenting with extra information.
     */
    memo?: string;
} & UserIdOrTokenInput;
/**
 * Represents the input parameters for retrieving a token.
 */
interface GetTokenInput {
    /**
     * The ID of the token to retrieve.
     */
    id: string;
}
/**
 * Represents the input for accelerating a transaction.
 */
type AccelerateTransactionInput = {
    /**
     * The ID of the transaction that should be accelerated.
     */
    id: string;
} & UserIdOrTokenInput & WithIdempotencyKey;
/**
 * Represents the input for cancelling a transaction.
 */
type CancelTransactionInput = {
    /**
     * The ID of the transaction that should be cancelled.
     */
    id: string;
} & UserIdOrTokenInput & WithIdempotencyKey;
/**
 * Defines the parameters for creating a new transaction.
 */
type CreateTransactionInput = {
    /**
     * Specifies the transfer amount in decimal format.
     */
    amounts: string[];
    /**
     * The recipient's blockchain address.
     */
    destinationAddress: string;
    /**
     * Identifier for the originating wallet.
     */
    walletId: string;
    /**
     * The list of NFT IDs to be transferred/batchTransferred for NFT withdrawal.
     * Note: Only erc1155 supports safeBatchTransferFrom.
     */
    nftTokenIds?: string[];
    /**
     * An optional client-provided reference or description for the transaction.
     */
    refId?: string;
    /**
     * Configuration to determine the fees that will be paid.
     */
    fee: FeeConfiguration<FeeLevel>;
} & UserIdOrTokenInput & TokenInfo & WithIdempotencyKey;
/**
 * Represents the input parameters for creating a new contract execution transaction.
 */
type CreateContractExecutionTransactionInput = ({
    /**
     * The contract ABI function signature or `callData` field is required for interacting with the smart contract. The ABI function signature cannot be used simultaneously with `callData`. e.g. Burn(uint256).
     */
    abiFunctionSignature: string;
    /**
     * The contract ABI function signature parameters for executing the contract interaction. Supported parameter types include string, integer, boolean, and array. These parameters should be used exclusively with the abiFunctionSignature and cannot be used with `callData`.
     */
    abiParameters: Array<any>;
    /**
     * The raw transaction data, must be an even-length hexadecimal string with the `0x` prefix, to be executed. It is important to note that the usage of `callData` is mutually exclusive with the `abiFunctionSignature` and `abiParameters`. Therefore, `callData` cannot be utilized simultaneously with either `abiFunctionSignature` or `abiParameters`.
     */
    callData?: undefined;
} | {
    /**
     * The contract ABI function signature or `callData` field is required for interacting with the smart contract. The ABI function signature cannot be used simultaneously with `callData`. e.g. Burn(uint256).
     */
    abiFunctionSignature?: undefined;
    /**
     * The contract ABI function signature parameters for executing the contract interaction. Supported parameter types include string, integer, boolean, and array. These parameters should be used exclusively with the abiFunctionSignature and cannot be used with `callData`.
     */
    abiParameters?: undefined;
    /**
     * The raw transaction data, must be an even-length hexadecimal string with the `0x` prefix, to be executed. It is important to note that the usage of `callData` is mutually exclusive with the `abiFunctionSignature` and `abiParameters`. Therefore, `callData` cannot be utilized simultaneously with either `abiFunctionSignature` or `abiParameters`.
     */
    callData: `0x${string}`;
}) & {
    /**
     * The amount of native token that will be sent to the contract abi execution. Optional field for payable api only, if not provided, no native token will be sent.
     */
    amount?: string;
    /**
     * The blockchain address of the contract to be executed.
     */
    contractAddress: string;
    /**
     * Optional reference or description used to identify the transaction.
     */
    refId?: string;
    /**
     * Unique system generated identifier of the wallet. Required when source Address and blockchain is not provided. Mutually exclusive. For contract deploys this wallet ID will be used as the source.
     */
    walletId: string;
    /**
     * Configuration that determines the fees that will be paid.
     */
    fee: FeeConfiguration<FeeLevel>;
} & UserIdOrTokenInput & WithIdempotencyKey;
/**
 * Represents the input parameters for estimating transfer fees.
 */
type EstimateContractExecutionFeeInput = ({
    /**
     * The contract ABI function signature to be interacted with in the smart contract. For example, `burn(uint256)`.
     */
    abiFunctionSignature: string;
    /**
     * The parameters required by the contract ABI function to perform the contract interaction.
     */
    abiParameters: Array<any>;
    /**
     * The raw transaction data, must be an even-length hexadecimal string with the 0x prefix, to be executed.
     * It is important to note that the usage of callData is mutually exclusive with the abiFunctionSignature and abiParameters.
     * Therefore, callData cannot be utilized simultaneously with either abiFunctionSignature or abiParameters.
     */
    callData?: undefined;
} | {
    /**
     * The contract ABI function signature to be interacted with in the smart contract. For example, `burn(uint256)`.
     */
    abiFunctionSignature?: undefined;
    /**
     * The parameters required by the contract ABI function to perform the contract interaction.
     */
    abiParameters?: undefined;
    /**
     * The raw transaction data, must be an even-length hexadecimal string with the 0x prefix, to be executed.
     * It is important to note that the usage of callData is mutually exclusive with the abiFunctionSignature and abiParameters.
     * Therefore, callData cannot be utilized simultaneously with either abiFunctionSignature or abiParameters.
     */
    callData: `0x${string}`;
}) & {
    /**
     * The blockchain address of the contract to be executed.
     */
    contractAddress: string;
    /**
     * Information about the source.
     */
    source: {
        /**
         * Identifier for the originating wallet.
         */
        walletId: string;
    } | {
        /**
         * Blockchain associated with the transaction. Required along with sourceAddress.
         */
        blockchain: ContractExecutionBlockchain;
        /**
         * The source blockchain address of the transaction.
         */
        sourceAddress: string;
    };
} & UserIdOrTokenInput;
/**
 * Represents the input parameters for estimating transfer fees.
 */
type EstimateTransferFeeInput = {
    /**
     * Specifies the transfer amount in decimal format.
     */
    amount: string[];
    /**
     * The recipient's blockchain address.
     */
    destinationAddress: string;
    /**
     * The source blockchain address of the transaction.
     */
    sourceAddress?: string;
    /**
     * Identifier for the originating wallet.
     */
    walletId?: string;
    /**
     * The list of NFT IDs to be transferred/batchTransferred for NFT withdrawal.
     * Note: Only ERC-1155 tokens support safeBatchTransferFrom.
     */
    nftTokenIds?: string[];
} & UserIdOrTokenInput & TokenInfo;
/**
 * Represents the input for retrieving a transaction.
 */
type GetTransactionInput = {
    /**
     * The ID of the transaction to retrieve.
     */
    id: string;
    /**
     * Filters on the transaction type of the transaction.
     */
    txType?: TransactionType;
} & UserIdOrTokenInput;
/**
 * Defines the parameters for querying a list of transactions.
 */
type ListTransactionsInput = {
    /**
     * Filters transactions based on the blockchain they occur on.
     */
    blockchain?: Blockchain;
    /**
     * Filters transactions based on their destination address.
     */
    destinationAddress?: string;
    /**
     * Determines whether the query should include all tokens.
     * If set to true, results will include all tokens.
     */
    includeAll?: boolean;
    /**
     * Filters transactions based on their operation.
     */
    operation?: ListTransactionsOperationEnum;
    /**
     * Filters transactions based on their current state.
     */
    state?: TransactionState;
    /**
     * Filters for a specific transaction hash.
     */
    txHash?: string;
    /**
     * Filters transactions based on their type.
     */
    txType?: TransactionType;
    /**
     * Filters transactions based on the owning wallets.
     * Input should be an array of walletIds.
     */
    walletIds?: string[];
} & UserIdOrTokenInput & Pagination;
/**
 * Represents the input parameters for validating an address.
 */
interface ValidateAddressInput {
    /**
     * The blockchain address to be validated.
     */
    address: string;
    /**
     * The blockchain that the address should belong to.
     */
    blockchain: Blockchain;
}
/**
 * Represents the input parameters for creating a user.
 */
type CreateUserInput = {
    /**
     * The unique identifier generated by your system for the user.
     */
    userId: string;
};
/**
 * Represents the input parameters for resending the OTP.
 */
type ResendOTPInput = {
    /**
     * The OTP is bound on a user and purpose, and uses this value to identify the request.
     */
    otpToken: string;
    /**
     * Sends OTP email to the destination address.
     */
    email: string;
    /**
     * Get the device id from SDK, and the deviceToken is bound with this device id.
     */
    deviceId: string;
} & WithIdempotencyKey & UserIdOrTokenInput;
/**
 * Represents the input parameters for creating a device token for email login.
 */
type CreateDeviceTokenForEmailLoginInput = {
    /**
     * Get the device id from SDK, and the deviceToken is bound with this device id.
     */
    deviceId: string;
    /**
     * Sends OTP email to the destination address.
     */
    email: string;
} & WithIdempotencyKey;
/**
 * Represents the input parameters for fetching a user.
 */
type GetUserInput = {
    /**
     * The unique identifier generated by your system for the user.
     */
    userId: string;
};
/**
 * Represents the input parameters for fetching a user by user token.
 */
type GetUserByTokenInput = {
    /**
     * The JSON Web Token (JWT) representing the user.
     */
    userToken: string;
};
/**
 * Represents the input parameters for fetching a challenge.
 */
type GetUserChallengeInput = {
    /**
     * The unique identifier for the challenge.
     */
    challengeId: string;
    /**
     * The JSON Web Token (JWT) representing the user.
     */
    userToken: string;
};
/**
 * Represents the input parameters for listing users.
 */
type ListUsersInput = {
    /**
     * The pin status to filter users. (Optional).
     */
    pinStatus?: ListUsersPinStatusEnum;
    /**
     * The security question status to filter users. (Optional).
     */
    securityQuestionStatus?: ListUsersSecurityQuestionStatusEnum;
} & Pagination;
/**
 * Represents the input parameters for fetching a user's challenges.
 */
type ListUserChallengesInput = {
    /**
     * The JSON Web Token (JWT) representing the user.
     */
    userToken: string;
    /**
     * The status of challenges to query. (Optional).
     */
    challengeStatus?: ListUserChallengesStatusEnum;
};
/**
 * Represents the input parameters for refreshing a user token.
 */
type RefreshUserTokenInput = {
    /**
     * Use the refresh token passed from sdk/performLogin to get a new userToken. Each refreshToken has a corresponding userToken for verification purposes.
     */
    refreshToken: string;
    /**
     * Get the device id from SDK, and the deviceToken is bound with this device id.
     */
    deviceId: string;
} & WithIdempotencyKey & UserIdOrTokenInput;
/**
 * Represents the input parameters for fetching a user.
 */
type CreateDeviceTokenForSocialLoginInput = {
    /**
     * Get the device id from SDK, and the deviceToken is bound with this device id.
     */
    deviceId: string;
} & WithIdempotencyKey;
/**
 * Represents the input parameters for creating a user token.
 */
type CreateUserTokenInput = {
    /**
     * The unique identifier generated by your system for the user.
     */
    userId: string;
};
/**
 * Represents the input parameters for creating multiple wallets.
 */
type CreateWalletsInput = {
    /**
     * The blockchains for which to create wallets.
     */
    blockchains: Blockchain[];
    /**
     * Optional list of metadata fields to associate with the corresponding wallet.
     * If count is specified, the amount of items in the array should match the count field.
     */
    metadata?: WalletMetadata[];
    /**
     * An account can be categorized as a Smart Contract Account (SCA) or an Externally Owned Account (EOA). For detailed information about these account types and their distinctions, please refer to the account types guide.
     *
     * By default, if an account type is not specified when creating a wallet, it will be classified as an Externally Owned Account (EOA).
     */
    accountType?: AccountType;
} & UserIdOrTokenInput & WithIdempotencyKey;
/**
 * Represents the input parameters for retrieving a wallet.
 */
type GetWalletInput = {
    /**
     * The ID of the wallet to retrieve.
     */
    id: string;
} & UserIdOrTokenInput;
/**
 * Represents the input parameters for retrieving the NFT balance of a wallet.
 */
type GetWalletNFTBalanceInput = {
    /**
     * The ID of the wallet to retrieve the NFTs for.
     */
    walletId: string;
    /**
     * Specifies whether to include all tokens.
     */
    includeAll?: boolean;
    /**
     * The name of the token to filter for.
     */
    name?: string;
    /**
     * An array of token addresses.
     */
    tokenAddresses?: string[];
    /**
     * Token standard.
     */
    standard?: TokenStandard;
} & UserIdOrTokenInput & Omit<Pagination, 'from' | 'to'>;
/**
 * Represents the input parameters for retrieving the token balance of a wallet.
 */
type GetWalletTokenBalanceInput = {
    /**
     * The ID of the wallet to retrieve the tokens for.
     */
    walletId: string;
    /**
     * Specifies whether to include all tokens.
     */
    includeAll?: boolean;
    /**
     * The name of the token to filter for.
     */
    name?: string;
    /**
     * An array of token addresses.
     */
    tokenAddresses?: string[];
    /**
     * Token standard.
     */
    standard?: TokenStandard;
} & UserIdOrTokenInput & Omit<Pagination, 'from' | 'to'>;
/**
 * Represents the input for listing wallets.
 */
type ListWalletsFilterInput = {
    /**
     * The address of the wallet to filter by.
     */
    address?: string;
    /**
     * The blockchain to filter by.
     */
    blockchain?: Blockchain;
    /**
     * The ID of the wallet set to filter by.
     */
    walletSetId?: string;
    /**
     * Reference or description used to identify the wallet.
     */
    refId?: string;
    /**
     * Filters results by the SCA version.
     */
    scaCore?: ScaCore;
} & UserIdOrTokenInput & Pagination;
/**
 * Represents the input parameters for updating a wallet.
 */
type UpdateWalletInput = {
    /**
     * The ID of the wallet to be updated.
     */
    id: string;
    /**
     * The new name for the wallet.
     */
    name?: string;
    /**
     * The new refId for the wallet.
     */
    refId?: string;
} & UserIdOrTokenInput;
/**
 * Represents input parameters for managing a user's PIN.
 */
type ManageUserPinInput = UserIdOrTokenInput & WithIdempotencyKey;

declare const defaultBaseUrl = "https://api.circle.com";
/**
 * A class-based client for Circle's User Controlled Wallets.
 * All operations are available as class methods.
 * @example
 * ```
 * import { CircleUserControlledWalletsClient, initiateUserControlledWalletsClient } from '@circle-fin/user-controlled-wallets'
 *
 * const client = initiateUserControlledWalletsClient({
 *   apiKey: 'YOUR_KEY',
 *   baseUrl: 'https://api.circle.com',
 * })
 *
 * const response = await client.listWallets({ userToken: 'dummy-user-token' })
 * console.log(response.data?.wallets)
 * ```
 */
declare class CircleUserControlledWalletsClient {
    private readonly params;
    /**
     * Creates an instance of CircleUserControlledWalletsClient.
     * @param config - API key, optional baseUrl, storage, userAgent, and headers.
     */
    constructor(config: ClientParams);
    /**
     * Create a challenge for PIN setup without setting up wallets.
     * @example
     * ```
     * const response = await client.createUserPin({
     *   userId: 'user-id',
     * })
     * console.log(response.data?.challengeId)
     * ```
     * @category PIN Authentication
     */
    createUserPin(input: ManageUserPinInput): Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.Pin>>;
    /**
     * Create a challenge for PIN setup and create wallet(s).
     * @example
     * ```
     * const response = await client.createUserPinWithWallets({
     *   userToken: 'dummy-user-token',
     *   blockchains: ['ETH'],
     * })
     * console.log(response.data?.challengeId)
     * ```
     * @category PIN Authentication
     */
    createUserPinWithWallets(input: CreateUserPinWithWalletsInput): Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.Pin>>;
    /**
     * Create a challenge to update a user's PIN via existing PIN.
     * @example
     * ```
     * const response = await client.updateUserPin({
     *   userToken: 'dummy-user-token',
     * })
     * console.log(response.data?.challengeId)
     * ```
     * @category PIN Authentication
     */
    updateUserPin(input: ManageUserPinInput): Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.Pin>>;
    /**
     * Create a challenge to change a user's PIN via security questions.
     * @example
     * ```
     * const response = await client.restoreUserPin({
     *   userToken: 'dummy-user-token',
     * })
     * console.log(response.data?.challengeId)
     * ```
     * @category PIN Authentication
     */
    restoreUserPin(input: ManageUserPinInput): Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.Pin>>;
    /**
     * Get a device token to login with email OTP.
     * @example
     * ```
     * const response = await client.createDeviceTokenForEmailLogin({
     *   deviceId: 'device-id',
     *   email: 'email@example.com',
     * })
     * console.log(response.data)
     * ```
     * @category Social & Email Authentication
     */
    createDeviceTokenForEmailLogin(input: CreateDeviceTokenForEmailLoginInput): Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.DeviceTokenEmail>>;
    /**
     * Get a device token to perform social login.
     * @example
     * ```
     * const response = await client.createDeviceTokenForSocialLogin({
     *   deviceId: 'device-id',
     * })
     * console.log(response.data)
     * ```
     * @category Social & Email Authentication
     */
    createDeviceTokenForSocialLogin(input: CreateDeviceTokenForSocialLoginInput): Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.DeviceTokenSocial>>;
    /**
     * Refresh the user token.
     * @example
     * ```
     * const response = await client.refreshUserToken({
     *   userToken: 'dummy-user-token',
     *   refreshToken: 'dummy-refresh-token',
     *   deviceId: 'device-id',
     * })
     * console.log(response.data)
     * ```
     * @category Social & Email Authentication
     */
    refreshUserToken(input: RefreshUserTokenInput): Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.RefreshUserToken>>;
    /**
     * Resend the OTP email.
     * @example
     * ```
     * const response = await client.resendOTP({
     *   userToken: "dummy-user-token",
     *   email: "email@example.com",
     *   otpToken: "otp-token",
     *   deviceId: "device-id",
     * })
     * console.log(response.data)
     * ```
     * @category Social & Email Authentication
     */
    resendOTP(input: ResendOTPInput): Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.ResentOTP>>;
    /**
     * Generates a challenge for creating a new user-controlled wallet.
     * @example
     * ```
     * const response = await client.createWallet({
     *   userToken: 'dummy-user-token',
     *   blockchains: ['ETH'],
     * })
     * console.log(response.data?.challengeId)
     * ```
     * @category Wallets
     */
    createWallet(input: CreateWalletsInput): Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.CreateEndUserWallet>>;
    /**
     * Retrieves a list of user-controlled wallets.
     * @example
     * ```
     * const response = await client.listWallets({
     *   userToken: 'dummy-user-token',
     * })
     * console.log(response.data?.wallets)
     * ```
     * @category Wallets
     */
    listWallets(input: ListWalletsFilterInput): Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.Wallets>>;
    /**
     * Retrieves a single user-controlled wallet by its unique identifier.
     * @example
     * ```
     * const response = await client.getWallet({
     *   id: 'wallet-id',
     *   userToken: 'dummy-user-token',
     * })
     * console.log(response.data?.wallet)
     * ```
     * @category Wallets
     */
    getWallet(input: GetWalletInput): Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.WalletResponse>>;
    /**
     * Updates a user-controlled wallet by its unique identifier.
     * @example
     * ```
     * const response = await client.updateWallet({
     *   id: 'wallet-id',
     *   userToken: 'dummy-user-token',
     *   name: 'New Name',
     * })
     * console.log(response.data?.wallet)
     * ```
     * @category Wallets
     */
    updateWallet(input: UpdateWalletInput): Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.WalletResponse>>;
    /**
     * Fetches the token balance for a user-controlled wallet.
     * @example
     * ```
     * const response = await client.getWalletTokenBalance({
     *   walletId: 'wallet-id',
     *   userToken: 'dummy-user-token',
     * })
     * console.log(response.data?.tokenBalances)
     * ```
     * @category Wallets
     */
    getWalletTokenBalance(input: GetWalletTokenBalanceInput): Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.Balances>>;
    /**
     * Fetches the NFT balance for a user-controlled wallet.
     * @example
     * ```
     * const response = await client.getWalletNFTBalance({
     *   walletId: 'wallet-id',
     *   userToken: 'dummy-user-token',
     * })
     * console.log(response.data?.nfts)
     * ```
     * @category Wallets
     */
    getWalletNFTBalance(input: GetWalletNFTBalanceInput): Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.Nfts>>;
    /**
     * Accelerates a transaction.
     * @example
     * ```
     * const response = await client.accelerateTransaction({
     *   userToken: 'dummy-user-token',
     *   id: 'transaction-id',
     * })
     * console.log(response.data?.challengeId)
     * ```
     * @category Transactions
     */
    accelerateTransaction(input: AccelerateTransactionInput): Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.AccelerateTransactionForEndUserResponse>>;
    /**
     * Creates a new transaction.
     * @example
     * ```
     * const response = await client.createTransaction({
     *   userToken: 'dummy-user-token',
     *   amounts: ['0.01'],
     *   destinationAddress: 'address',
     *   tokenId: 'token-id',
     *   walletId: 'wallet-id',
     *   fee: {
     *     type: 'level',
     *     config: {
     *       feeLevel: 'HIGH',
     *     },
     *   },
     * })
     * console.log(response.data?.challengeId)
     * ```
     * @category Transactions
     */
    createTransaction(input: CreateTransactionInput): Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.CreateTransferTransactionForEndUserResponse>>;
    /**
     * Cancels an existing transaction.
     * @example
     * ```
     * const response = await client.cancelTransaction({
     *   id: 'transaction-id',
     *   userToken: 'dummy-user-token',
     * })
     * console.log(response.data?.challengeId)
     * ```
     * @category Transactions
     */
    cancelTransaction(input: CancelTransactionInput): Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.CancelTransactionForEndUserResponse>>;
    /**
     * Retrieves a transaction by its unique identifier.
     * @example
     * ```
     * const response = await client.getTransaction({
     *   userToken: 'dummy-user-token',
     *   id: 'transaction-id',
     * })
     * console.log(response.data)
     * ```
     * @category Transactions
     */
    getTransaction(input: GetTransactionInput): Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.TransactionResponse>>;
    /**
     * Lists all transactions.
     * @example
     * ```
     * const response = await client.listTransactions({
     *   userToken: 'dummy-user-token',
     * })
     * console.log(response.data?.transactions)
     * ```
     * @category Transactions
     */
    listTransactions(input: ListTransactionsInput): Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.Transactions>>;
    /**
     * Estimates gas fees for a contract execution transaction.
     * @example
     * ```
     * const response = await client.estimateContractExecutionFee({
     *   abiFunctionSignature: 'functionSig',
     *   abiParameters: [param1],
     *   contractAddress: 'contract-id',
     *   source: { walletId: 'wallet-id' },
     *   userId: 'user-id',
     * })
     * console.log(response.data)
     * ```
     * @category Transactions
     */
    estimateContractExecutionFee(input: EstimateContractExecutionFeeInput): Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.EstimateTransactionFee>>;
    /**
     * Creates a challenge for executing a contract transaction.
     * @example
     * ```
     * const response = await client.createUserTransactionContractExecutionChallenge({
     *   userToken: "dummy-user-token",
     *   abiFunctionSignature: "functionSig",
     *   abiParameters: ["param1"],
     *   contractAddress: "contract-id",
     *   walletId: "wallet-id",
     *   fee: {
     *     type: "level",
     *     config: {
     *       feeLevel: "HIGH",
     *     },
     *   },
     * })
     * console.log(response.data?.challengeId)
     * ```
     * @category Transactions
     */
    createUserTransactionContractExecutionChallenge(input: CreateContractExecutionTransactionInput): Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.CreateContractExecutionTransactionForEndUserResponse>>;
    /**
     * Estimates gas fees for a transfer transaction.
     * @example
     * ```
     * const response = await client.estimateTransferFee({
     *   amount: ["0.01"],
     *   destinationAddress: "address",
     *   tokenId: "token-id",
     *   userToken: "dummy-user-token",
     * })
     * console.log(response.data)
     * ```
     * @category Transactions
     */
    estimateTransferFee(input: EstimateTransferFeeInput): Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.EstimateTransactionFee>>;
    /**
     * Validates an address for a specific blockchain.
     * @example
     * ```
     * const response = await client.validateAddress({
     *   address: 'address',
     *   blockchain: 'ETH',
     * })
     * console.log(response.data?.isValid)
     * ```
     * @category Transactions
     */
    validateAddress(input: ValidateAddressInput): Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.ValidateAddress>>;
    /**
     * Creates a new user.
     * @example
     * ```
     * const response = await client.createUser({
     *   userId: 'user-id',
     * })
     * console.log(response.status)
     * ```
     * @category Users
     */
    createUser(input: CreateUserInput): Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.UserResponse>>;
    /**
     * Retrieves a user by ID.
     * @example
     * ```
     * const response = await client.getUser({
     *   userId: 'user-id',
     * })
     * console.log(response.data?.user)
     * ```
     * @category Users
     */
    getUser(input: GetUserInput): Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.GetUserByIDResponse>>;
    /**
     * Retrieves user status via token.
     * @example
     * ```
     * const response = await client.getUserStatus({
     *   userToken: 'dummy-user-token',
     * })
     * console.log(response.data)
     * ```
     * @category Users
     */
    getUserStatus(input: GetUserByTokenInput): Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.UserResponse>>;
    /**
     * Lists all users.
     * @example
     * ```
     * const response = await client.listUsers()
     * console.log(response.data?.users)
     * ```
     * @category Users
     */
    listUsers(input?: ListUsersInput): Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.Users>>;
    /**
     * Creates a user token.
     * @example
     * ```
     * const response = await client.createUserToken({
     *   userId: 'user-id',
     * })
     * console.log(response.data)
     * ```
     * @category Users
     */
    createUserToken(input: CreateUserTokenInput): Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.UserTokenResponse>>;
    /**
     * Retrieves a user challenge by token.
     * @example
     * ```
     * const response = await client.getUserChallenge({
     *   userToken: 'dummy-user-token',
     *   challengeId: 'challenge-id',
     * })
     * console.log(response.data?.challenge)
     * ```
     * @category Users
     */
    getUserChallenge(input: GetUserChallengeInput): Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.ChallengeResponse>>;
    /**
     * Lists all user challenges.
     * @example
     * ```
     * const response = await client.listUserChallenges({
     *   userToken: 'dummy-user-token',
     * })
     * console.log(response.data?.challenges)
     * ```
     * @category Users
     */
    listUserChallenges(input: ListUserChallengesInput): Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.Challenges>>;
    /**
     * Fetches details of a specific token.
     * @example
     * ```
     * const response = await client.getToken({
     *   id: 'token-id',
     * })
     * console.log(response.data?.token)
     * ```
     * @category Token Lookup
     */
    getToken(input: GetTokenInput): Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.TokenResponse>>;
    /**
     * Signs an EIP-191 message.
     * @example
     * ```
     * const response = await client.signMessage({
     *   userToken: 'dummy-user-token',
     *   walletId: 'wallet-id',
     *   encodedByHex: false,
     *   message: 'I agree with this transfer',
     *   memo: 'Transfer',
     * })
     * console.log(response.data?.challengeId)
     * ```
     * @category Signing
     */
    signMessage(input: SignMessageInput): Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.Signature>>;
    /**
     * Signs a transaction.
     * @example
     * ```
     * const response = await client.signTransaction({
     *   userToken: 'dummy-user-token',
     *   walletId: 'wallet-id',
     *   rawTransaction: 'raw-tx',
     *   memo: 'Transfer',
     * })
     * console.log(response.data?.challengeId)
     * ```
     * @category Signing
     */
    signTransaction(input: SignTransactionInput): Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.SignTransactionResponse>>;
    /**
     * Signs EIP-712 typed data.
     * @example
     * ```
     * const response = await client.signTypedData({
     *   userToken: 'dummy-user-token',
     *   walletId: 'wallet-id',
     *   data: 'typed-data',
     *   memo: 'Transfer',
     * })
     * console.log(response.data?.challengeId)
     * ```
     * @category Signing
     */
    signTypedData(input: SignTypedDataInput): Promise<_shared_core.TrimDataResponse<_shared_clients_user_controlled_wallets.Signature>>;
    /**
     * Requests testnet tokens.
     * @example
     * ```
     * const response = await client.requestTestnetTokens({
     *   address: 'wallet-address',
     *   blockchain: 'TestnetBlockchain',
     * })
     * console.log(response.status)
     * ```
     * @category Faucet
     */
    requestTestnetTokens(input: RequestTestnetTokensInput): Promise<axios.AxiosResponse<void, any>>;
    /**
     * Adds a token to the monitored tokens list.
     * @example
     * ```
     * const response = await client.createMonitoredTokens({
     *   tokenIds: ['token-id'],
     * })
     * console.log(response)
     * ```
     * @category Monitored Tokens
     */
    createMonitoredTokens(input: CreateMonitoredTokensInput): Promise<_shared_core.TrimDataResponse<_shared_clients_configurations.MonitoredTokens>>;
    /**
     * Updates the monitored tokens list.
     * @example
     * ```
     * const response = await client.updateMonitoredTokens({
     *   tokenIds: ['token-id'],
     * })
     * console.log(response)
     * ```
     * @category Monitored Tokens
     */
    updateMonitoredTokens(input: UpdateMonitoredTokensInput): Promise<_shared_core.TrimDataResponse<_shared_clients_configurations.MonitoredTokens>>;
    /**
     * Retrieves monitored tokens.
     * @example
     * ```
     * const response = await client.listMonitoredTokens()
     * console.log(response)
     * ```
     * @category Monitored Tokens
     */
    listMonitoredTokens(input?: ListMonitoredTokensInput): Promise<_shared_core.TrimDataResponse<_shared_clients_configurations.MonitoredTokens>>;
    /**
     * Deletes tokens from the monitored tokens list.
     * @example
     * ```
     * const response = await client.deleteMonitoredTokens({
     *   tokenIds: ['token-id'],
     * })
     * console.log(response)
     * ```
     * @category Monitored Tokens
     */
    deleteMonitoredTokens(input: DeleteMonitoredTokensInput): Promise<axios.AxiosResponse<void, any>>;
    /**
     * Updates the monitored tokens scope.
     * @example
     * ```
     * const response = await client.updateMonitoredTokensScope({
     *   scope: 'MONITOR_ALL',
     * })
     * console.log(response)
     * ```
     * @category Monitored Tokens
     */
    updateMonitoredTokensScope(input: UpdateMonitoredTokensScopeInput): Promise<axios.AxiosResponse<void, any>>;
    /**
     * Creates a notification subscription.
     * @example
     * ```
     * const response = await client.createSubscription({
     *   endpoint: 'https://example.com/notifications',
     * })
     * console.log(response)
     * ```
     * @category Webhook Subscriptions
     */
    createSubscription(input: CreateSubscriptionInput): Promise<_shared_core.TrimDataResponse<_shared_clients_configurations.SubscriptionResponse>>;
    /**
     * Deletes a notification subscription.
     * @example
     * ```
     * const response = await client.deleteSubscription('subscription-id')
     * console.log(response)
     * ```
     * @category Webhook Subscriptions
     */
    deleteSubscription(subscriptionId: string): Promise<axios.AxiosResponse<void, any>>;
    /**
     * Retrieves a notification subscription.
     * @example
     * ```
     * const response = await client.getSubscription('subscription-id')
     * console.log(response)
     * ```
     * @category Webhook Subscriptions
     */
    getSubscription(subscriptionId: string): Promise<_shared_core.TrimDataResponse<_shared_clients_configurations.SubscriptionResponse>>;
    /**
     * Retrieves the public key and algorithm for notification signature.
     * @example
     * ```
     * const response = await client.getNotificationSignature('subscription-id')
     * console.log(response)
     * ```
     * @category Webhook Subscriptions
     */
    getNotificationSignature(subscriptionId: string): Promise<_shared_core.TrimDataResponse<_shared_clients_configurations.NotificationSignaturePublicKey>>;
    /**
     * Lists all notification subscriptions.
     * @example
     * ```
     * const response = await client.listSubscriptions()
     * console.log(response)
     * ```
     * @category Webhook Subscriptions
     */
    listSubscriptions(): Promise<_shared_core.TrimDataResponse<_shared_clients_configurations.Subscriptions>>;
    /**
     * Updates a notification subscription.
     * @example
     * ```
     * const response = await client.updateSubscription({
     *   id: 'subscription-id',
     *   name: 'new-name',
     *   enabled: true,
     * })
     * console.log(response)
     * ```
     * @category Webhook Subscriptions
     */
    updateSubscription(input: UpdateSubscriptionInput): Promise<_shared_core.TrimDataResponse<_shared_clients_configurations.SubscriptionResponse>>;
}
/**
 * Initiates a client for Circle's User Controlled Wallets.
 * @example
 * ```
 * import { initiateUserControlledWalletsClient } from '@circle-fin/user-controlled-wallets'
 *
 * const client = initiateUserControlledWalletsClient({
 *   apiKey: 'YOUR_KEY',
 * })
 *
 * const response = await client.listWallets({ userToken: 'dummy-user-token' })
 * console.log(response.data?.wallets)
 * ```
 * @param config - The client parameters.
 * @returns The client object with various methods.
 * @category Initialization
 */
declare function initiateUserControlledWalletsClient(config: ClientParams): CircleUserControlledWalletsClient;

export { type APIParams, type AccelerateTransactionInput, type CancelTransactionInput, CircleUserControlledWalletsClient, type ClientParams, type CreateContractExecutionTransactionInput, type CreateDeviceTokenForEmailLoginInput, type CreateDeviceTokenForSocialLoginInput, type CreateTransactionInput, type CreateUserInput, type CreateUserPinWithWalletsInput, type CreateUserTokenInput, type CreateWalletsInput, type EstimateContractExecutionFeeInput, type EstimateTransferFeeInput, type GetTokenInput, type GetTransactionInput, type GetUserByTokenInput, type GetUserChallengeInput, type GetUserInput, type GetWalletInput, type GetWalletNFTBalanceInput, type GetWalletTokenBalanceInput, type ListTransactionsInput, type ListUserChallengesInput, type ListUsersInput, type ListWalletsFilterInput, type ManageUserPinInput, type RefreshUserTokenInput, type ResendOTPInput, type SignMessageInput, type SignTransactionInput, type SignTypedDataInput, type TokenAddressAndBlockchainInput, type TokenIdInput, type TokenInfo, type UpdateWalletInput, type UserIdInput, type UserIdOrTokenInput, type UserTokenInput, type ValidateAddressInput, defaultBaseUrl, initiateUserControlledWalletsClient };
